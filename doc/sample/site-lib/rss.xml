<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[MyKM]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>MyKM</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 06 Dec 2025 07:44:31 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 06 Dec 2025 07:44:30 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Fx5u - Sample]]></title><description><![CDATA[State Machine Diagram
<img src="assets/pasted-image-20251206153353.png" target="_self">run only onece, when system starting up;
yLight := TRUE; sys.ManMode := TRUE;
//gCanChangePage := TRUE; ySt3ServoServoBrake := TRUE;
ySt3ServoServoOn := TRUE; IF dwSt3Seperation = 0 THEN dwSt3Seperation := 4;
END_IF; SM8049 := TRUE;
OK_STEP	字[有符号]	VAR_GLOBAL_CONSTANT 10000 0
NG_STEP	字[有符号]	VAR_GLOBAL_CONSTANT -1 0
START_STEP	字[有符号]	VAR_GLOBAL_CONSTANT 10 0
TOOL_NG	字[有符号]	VAR_GLOBAL_CONSTANT 900 0
ErrCyOn	字[无符号]/位串[16位]	VAR_GLOBAL_CONSTANT 10	Cylinder On Err 0
ErrCyOff	字[无符号]/位串[16位]	VAR_GLOBAL_CONSTANT 20	Cylinder Off Err 0
ErrCyBoth	字[无符号]/位串[16位]	VAR_GLOBAL_CONSTANT 30	Cylinder Both On Err 0
CONTINUS_NG_TARGET	字[有符号]	VAR_GLOBAL_CONSTANT 3 0
STEP_BUSY	字[有符号]	VAR_GLOBAL_CONSTANT 1 0
STEP_OK	字[有符号]	VAR_GLOBAL_CONSTANT 2 0
gLight	dsTowerLight	VAR_GLOBAL	详细设置 0
sys	dsSysStatus	VAR_GLOBAL	详细设置 0
dwAxis1Pos	双字[有符号]	VAR_GLOBAL	SD5500 0
dwAxis2Pos	双字[有符号]	VAR_GLOBAL	SD5540 0
uiSt1Down	位	VAR_GLOBAL	M10 0
uiSt1Forward	位	VAR_GLOBAL	M11 0
uiSt1Clamp	位	VAR_GLOBAL	M12 0
uiSt1ClampRotate	位	VAR_GLOBAL	M13 0
uiSt1Seperate	位	VAR_GLOBAL	M14 0
uiSt1PF	位	VAR_GLOBAL	M15 0
uiSt1LF	位	VAR_GLOBAL	M16 0
uiSt3Down	位	VAR_GLOBAL	M30 0
uiSt3Forward	位	VAR_GLOBAL	M31 0
uiSt3Suck	位	VAR_GLOBAL	M32 0
uiSt3StepUp	位	VAR_GLOBAL	M33 0
uiSt3StepDown	位	VAR_GLOBAL	M34 0
uiSt3NextPos	位	VAR_GLOBAL	M35 0
uiSt5Down	位	VAR_GLOBAL	M50 0
uiSt5Forward	位	VAR_GLOBAL	M51 0
uiSt5Suck	位	VAR_GLOBAL	M52 0
uiSt5Seperate	位	VAR_GLOBAL	M53 0
uiSt5PF	位	VAR_GLOBAL	M54 0
uiSt5LF	位	VAR_GLOBAL	M55 0
uiSt6Down	位	VAR_GLOBAL	M60 0
uiSt7Down	位	VAR_GLOBAL	M70 0
uiSt8Down	位	VAR_GLOBAL	M80 0
uiSt8Forward	位	VAR_GLOBAL	M81 0
uiSt8Clamp	位	VAR_GLOBAL	M82 0
uiSt9Up	位	VAR_GLOBAL	M90 uiSt9BlowAir	位	VAR_GLOBAL	M91 cySt1Down	FbCylinder2x1y	VAR_GLOBAL cySt1Forward	FbCylinder2x1y	VAR_GLOBAL cySt1Clamp	FbCylinder0x1y	VAR_GLOBAL cySt1ClampRotate	FbCylinder2x1y	VAR_GLOBAL cySt1Seperate	FbCylinder2x1y	VAR_GLOBAL cySt3Down	FbCylinder2x1y	VAR_GLOBAL cySt3Forward	FbCylinder2x1y	VAR_GLOBAL cySt3Suck	FbCylinder1x1y	VAR_GLOBAL cySt5Down	FbCylinder2x1y	VAR_GLOBAL cySt5Forward	FbCylinder2x1y	VAR_GLOBAL cySt5Suck	FbCylinder1x1y	VAR_GLOBAL cySt5Seperate	FbCylinder2x1y	VAR_GLOBAL cySt6Down	FbCylinder2x1y	VAR_GLOBAL cySt7Down	FbCylinder2x1y	VAR_GLOBAL cySt8Down	FbCylinder2x1y	VAR_GLOBAL 0
cySt8Forward	FbCylinder2x1y	VAR_GLOBAL 0
cySt8Clamp	FbCylinder0x1y	VAR_GLOBAL 0
cySt9Up	FbCylinder2x1y	VAR_GLOBAL 0
cySt9BlowAir	FbCylinder0x1y	VAR_GLOBAL 0
rfSt1	FbFeeder	VAR_GLOBAL 0
rfSt5	FbFeeder	VAR_GLOBAL RotateTable	FbRotateTable	VAR_GLOBAL Axis1Zero	FbAxisZero	VAR_GLOBAL Axis2Zero	FbAxisZero	VAR_GLOBAL wSt1ClampOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1000 wSt1ClampOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1001 wSt1ClampRotateOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1002 wSt1ClampRotateOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1003 wSt1ClampRotateTO	字[有符号]	VAR_GLOBAL_RETAIN	D1004 wSt1DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1005 wSt1DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1006 wSt1DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1007 wSt1ForwardOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1008 wSt1ForwardOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1009 wSt1ForwardTO	字[有符号]	VAR_GLOBAL_RETAIN	D1010 wSt1SeperateOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1011 wSt1SeperateOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1012 wSt1SeperateTO	字[有符号]	VAR_GLOBAL_RETAIN	D1013 wSt3DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1014 wSt3DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1015 wSt3DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1016 wSt3ForwardOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1017 wSt3ForwardOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1018 wSt3ForwardTO	字[有符号]	VAR_GLOBAL_RETAIN	D1019 wSt3SuckOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1020 wSt3SuckOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1021 wSt3SuckTO	字[有符号]	VAR_GLOBAL_RETAIN	D1022 wSt5DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1023 wSt5DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1024 wSt5DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1025 wSt5ForwardOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1026 wSt5ForwardOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1027 wSt5ForwardTO	字[有符号]	VAR_GLOBAL_RETAIN	D1028 wSt5SeperateOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1029 wSt5SeperateOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1030 wSt5SeperateTO	字[有符号]	VAR_GLOBAL_RETAIN	D1031 wSt5SuckOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1032 wSt5SuckOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1033 wSt5SuckTO	字[有符号]	VAR_GLOBAL_RETAIN	D1034 wSt6DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1035 wSt6DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1036 wSt6DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1037 wSt7DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1038 wSt7DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1039 wSt7DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1040 wSt8ClampOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1041 wSt8ClampOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1042 wSt8DownOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1043 wSt8DownOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1044 wSt8DownTO	字[有符号]	VAR_GLOBAL_RETAIN	D1045 wSt8ForwardOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1046 wSt8ForwardOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1047 wSt8ForwardTO	字[有符号]	VAR_GLOBAL_RETAIN	D1048 wSt9BlowAirOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1049 wSt9BlowAirOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1050 wSt9UpOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1051 wSt9UpOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1052 wSt9UpTO	字[有符号]	VAR_GLOBAL_RETAIN	D1053 wSt7WaitChk	字[有符号]	VAR_GLOBAL_RETAIN	D1054 wSt6DownWait	字[有符号]	VAR_GLOBAL_RETAIN	D1055 wSt1FeedInOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1060 wSt1FeedInTO	字[有符号]	VAR_GLOBAL_RETAIN	D1061 wSt1FullOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1062 wSt1FullOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1063 wSt1FullTO	字[有符号]	VAR_GLOBAL_RETAIN	D1064 wSt5FeedInOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1065 wSt5FeedInTO	字[有符号]	VAR_GLOBAL_RETAIN	D1066 wSt5FullOnT	字[有符号]	VAR_GLOBAL_RETAIN	D1067 wSt5FullOffT	字[有符号]	VAR_GLOBAL_RETAIN	D1068 wSt5FullTO	字[有符号]	VAR_GLOBAL_RETAIN	D1069 wSt7AbsNUL	字[有符号]	VAR_GLOBAL_RETAIN	D1070 wSt7AbsPUL	字[有符号]	VAR_GLOBAL_RETAIN	D1072 wSt7RelNUL	字[有符号]	VAR_GLOBAL_RETAIN	D1074 wSt7RelPUL	字[有符号]	VAR_GLOBAL_RETAIN	D1076 wRotateOnPosWaitT	字[有符号]	VAR_GLOBAL_RETAIN	D1077 wRotateTO	字[有符号]	VAR_GLOBAL_RETAIN	D1078 dwA1AbsSpeed	双字[有符号]	VAR_GLOBAL_RETAIN	D1080 dwA2AbsSpeed	双字[有符号]	VAR_GLOBAL_RETAIN	D1082 dwA1JogSpeed	双字[有符号]	VAR_GLOBAL_RETAIN	D1084 dwA2JogSpeed	双字[有符号]	VAR_GLOBAL_RETAIN	D1086 dwSt3ShiftAngle	双字[有符号]	VAR_GLOBAL_RETAIN	D1090 dwSt3SafeHeight	双字[有符号]	VAR_GLOBAL_RETAIN	D1092 dwSt3ToolCheck	双字[有符号]	VAR_GLOBAL_RETAIN	D1094 空料檢查高度 dwAxis2GoUp	双字[有符号]	VAR_GLOBAL_RETAIN	D1096 wTotalOkCnt	双字[无符号]/位串[32位]	VAR_GLOBAL_RETAIN	D1100 wProductOkCount	双字[无符号]/位串[32位]	VAR_GLOBAL_RETAIN	D1102 wProductNgCount	双字[无符号]/位串[32位]	VAR_GLOBAL_RETAIN	D1104 wStopMachineNumber	双字[无符号]/位串[32位]	VAR_GLOBAL_RETAIN	D1106 dwSt3Seperation	双字[无符号]/位串[32位]	VAR_GLOBAL_RETAIN	D1110 分割數設定 wSt3ToolChkT	字[有符号]	VAR_GLOBAL_RETAIN	D1112 wSt3NoToolChkTO	字[有符号]	VAR_GLOBAL_RETAIN	D1113 dwSt3FeedUpSpeed	双字[有符号]	VAR_GLOBAL_RETAIN	D1114 uiSt1Cycle	位	VAR_GLOBAL	M100 uiSt3Cycle	位	VAR_GLOBAL	M101 uiSt5Cycle	位	VAR_GLOBAL	M102 uiSt6Cycle	位	VAR_GLOBAL	M103 uiSt7Cycle	位	VAR_GLOBAL	M104 uiSt8Cycle	位	VAR_GLOBAL	M105 uiSt9Cycle	位	VAR_GLOBAL	M106 St1Cycle	位	VAR_GLOBAL	M107 St3Cycle	位	VAR_GLOBAL	M108 St5Cycle	位	VAR_GLOBAL	M109 St6Cycle	位	VAR_GLOBAL	M110 St7Cycle	位	VAR_GLOBAL	M111 St8Cycle	位	VAR_GLOBAL	M112 St9Cycle	位	VAR_GLOBAL	M113 autoSt1Cycle	位	VAR_GLOBAL	M114 autoSt3Cycle	位	VAR_GLOBAL	M115 autoSt5Cycle	位	VAR_GLOBAL	M116 autoSt6Cycle	位	VAR_GLOBAL	M117 autoSt7Cycle	位	VAR_GLOBAL	M118 autoSt8Cycle	位	VAR_GLOBAL	M119 autoSt9Cycle	位	VAR_GLOBAL	M120 uiSt1Reset	位	VAR_GLOBAL	M121 uiSt3Reset	位	VAR_GLOBAL	M122 uiSt5Reset	位	VAR_GLOBAL	M123 uiSt6Reset	位	VAR_GLOBAL	M124 uiSt7Reset	位	VAR_GLOBAL	M125 uiSt8Reset	位	VAR_GLOBAL	M126 uiSt9Reset	位	VAR_GLOBAL	M127 St1InOrg	位	VAR_GLOBAL	M128 St3InOrg	位	VAR_GLOBAL	M129 St5InOrg	位	VAR_GLOBAL	M130 St6InOrg	位	VAR_GLOBAL	M131 St7InOrg	位	VAR_GLOBAL	M132 St8InOrg	位	VAR_GLOBAL	M133 St9InOrg	位	VAR_GLOBAL	M134 St6CanGoNext	位	VAR_GLOBAL	M138 St7CanGoNext	位	VAR_GLOBAL	M139 St8CanGoNext	位	VAR_GLOBAL	M140 St9CanGoNext	位	VAR_GLOBAL	M141 St6GoNext	位	VAR_GLOBAL	M145 St7GoNext	位	VAR_GLOBAL	M146 St8GoNext	位	VAR_GLOBAL	M147 St9GoNext	位	VAR_GLOBAL	M148 gSt1Down	位	VAR_GLOBAL	M149 gSt1Forward	位	VAR_GLOBAL	M150 gSt1Clamp	位	VAR_GLOBAL	M151 gSt1ClampRotate	位	VAR_GLOBAL	M152 gSt1Seperate	位	VAR_GLOBAL	M153 gSt3Down	位	VAR_GLOBAL	M154 gSt3Forward	位	VAR_GLOBAL	M155 gSt3Suck	位	VAR_GLOBAL	M156 gSt5Down	位	VAR_GLOBAL	M157 gSt5Forward	位	VAR_GLOBAL	M158 gSt5Suck	位	VAR_GLOBAL	M159 gSt5Seperate	位	VAR_GLOBAL	M160 gSt6Down	位	VAR_GLOBAL	M161 gSt7Down	位	VAR_GLOBAL	M162 gSt8Down	位	VAR_GLOBAL	M163 gSt8Forward	位	VAR_GLOBAL	M164 gSt8Clamp	位	VAR_GLOBAL	M165 gSt9Up	位	VAR_GLOBAL	M166 gSt9BlowAir	位	VAR_GLOBAL	M167 uiIndexRotate	位	VAR_GLOBAL	M170 gRotate	位	VAR_GLOBAL	M171 uiResetAlarm	位	VAR_GLOBAL	M172 ResetAlarm	位	VAR_GLOBAL	M173 uiEnBuzzer	位	VAR_GLOBAL	M174 uiRstTotalOkCnt	位	VAR_GLOBAL	M175 uiRstOkCnt	位	VAR_GLOBAL	M176 uiRstNgCnt	位	VAR_GLOBAL	M177 gCanChangePage	位	VAR_GLOBAL	M178 gSt7Result	位	VAR_GLOBAL	M179 gSt7ResetZero	位	VAR_GLOBAL	M180 uiStartAuto	位	VAR_GLOBAL	M210 uiStopAuto	位	VAR_GLOBAL	M211 uiClearTool	位	VAR_GLOBAL	M212 uiFeeder	位	VAR_GLOBAL	M213 gA1Zero	位	VAR_GLOBAL	M214 伺服旋轉 gA2Zero	位	VAR_GLOBAL	M215 步進上下 uiA1Zero	位	VAR_GLOBAL	M216 uiA2Zero	位	VAR_GLOBAL	M217 gCurrentPage	字[有符号]	VAR_GLOBAL	D10 wSt1Index	字[有符号]	VAR_GLOBAL	D30 wSt3Index	字[有符号]	VAR_GLOBAL	D31 wSt5Index	字[有符号]	VAR_GLOBAL	D32 wSt6Index	字[有符号]	VAR_GLOBAL	D33 wSt7Index	字[有符号]	VAR_GLOBAL	D34 wSt8Index	字[有符号]	VAR_GLOBAL	D35 wSt9Index	字[有符号]	VAR_GLOBAL	D36 wSt1LastIndex	字[有符号]	VAR_GLOBAL	D37 wSt3LastIndex	字[有符号]	VAR_GLOBAL	D38 wSt5LastIndex	字[有符号]	VAR_GLOBAL	D39 wSt6LastIndex	字[有符号]	VAR_GLOBAL	D40 wSt7LastIndex	字[有符号]	VAR_GLOBAL	D41 wSt8LastIndex	字[有符号]	VAR_GLOBAL	D42 wSt9LastIndex	字[有符号]	VAR_GLOBAL	D43 wSt7AbsValue	字[有符号]	VAR_GLOBAL	D50 wSt7RelValue	字[有符号]	VAR_GLOBAL	D52 wSt7Base	字[有符号]	VAR_GLOBAL	D54 dwA1MoveDist	双字[有符号]	VAR_GLOBAL dwA1MoveSpeed	双字[有符号]	VAR_GLOBAL dwA1Step	双字[有符号]	VAR_GLOBAL	D62 dwA2MoveDist	双字[有符号]	VAR_GLOBAL dwA2MoveSpeed	双字[有符号]	VAR_GLOBAL dwA2Step	双字[有符号]	VAR_GLOBAL	D66 wA1MoveT	字[有符号]	VAR_GLOBAL	D68 軸1位移時間 wA2MoveT	字[有符号]	VAR_GLOBAL	D69 軸2位移時間 gA1IO	dsAxisIO	VAR_GLOBAL gA2IO	dsAxisIO	VAR_GLOBAL gSt1RotatoryFeeder	位	VAR_GLOBAL 0
gSt5RotatoryFeeder	位	VAR_GLOBAL 0
gEnStopCount	位	VAR_GLOBAL_RETAIN	M1000 Enable stop machine count UseSt2	位	VAR_GLOBAL_RETAIN	M1002 UseSt3	位	VAR_GLOBAL_RETAIN	M1003 UseSt4	位	VAR_GLOBAL_RETAIN	M1004 UseSt5	位	VAR_GLOBAL_RETAIN	M1005 UseSt6	位	VAR_GLOBAL_RETAIN	M1006 UseSt7	位	VAR_GLOBAL_RETAIN	M1007 UseSt8	位	VAR_GLOBAL_RETAIN	M1008 UseSt9	位	VAR_GLOBAL_RETAIN	M1009 gA1ZeroDone	位	VAR_GLOBAL gA2ZeroDone	位	VAR_GLOBAL gAllCylinderOff	位	VAR_GLOBAL gA1InPos1	位	VAR_GLOBAL gA2InPos1	位	VAR_GLOBAL gAllHomeDone	位	VAR_GLOBAL	M76 gCanHomeInit	位	VAR_GLOBAL gA1Abs	位	VAR_GLOBAL gA1CanMove	位	VAR_GLOBAL gA1InPos	位	VAR_GLOBAL gA1Jog	位	VAR_GLOBAL gA1JogDone	位	VAR_GLOBAL gA1Move	位	VAR_GLOBAL gA1MoveDone	位	VAR_GLOBAL 2bit gA2Abs	位	VAR_GLOBAL gA2CanMove	位	VAR_GLOBAL gA2InPos	位	VAR_GLOBAL gA2JogDone	位	VAR_GLOBAL gA2Move	位	VAR_GLOBAL gA2MoveDone	位	VAR_GLOBAL 2bit gStopA1	位	VAR_GLOBAL gStopA2	位	VAR_GLOBAL gA1TouchLimit	位	VAR_GLOBAL gA2TouchLimit	位	VAR_GLOBAL gMoveA1Abs	位	VAR_GLOBAL gMoveA2Abs	位	VAR_GLOBAL uiA1StepP	位	VAR_GLOBAL	M218 uiA1StepN	位	VAR_GLOBAL	M219 uiA2StepP	位	VAR_GLOBAL	M220 uiA2StepN	位	VAR_GLOBAL	M221 uiA1JogP	位	VAR_GLOBAL	M222 uiA1JogN	位	VAR_GLOBAL	M223 uiA2JogP	位	VAR_GLOBAL	M224 uiA2JogN	位	VAR_GLOBAL	M225 uiA1MoveAbs	位	VAR_GLOBAL	M226 uiA2MoveAbs	位	VAR_GLOBAL	M227 uiLight	位	VAR_GLOBAL	M228 uiStopA1	位	VAR_GLOBAL	M229 uiStopA2	位	VAR_GLOBAL	M230 uiAllAxisZero	位	VAR_GLOBAL	M231 gAllAxisZero	位	VAR_GLOBAL	M232 gAllAxisZeroDone	位	VAR_GLOBAL	M233 gAllStCanCycle	位	VAR_GLOBAL	M234 uiGetSt3Angle	位	VAR_GLOBAL	M235 uiGetSt3Height	位	VAR_GLOBAL	M236 gSt3RotateSafe	位	VAR_GLOBAL	M237 manA1Zero	位	VAR_GLOBAL	M238 Servo Rotate manA2Zero	位	VAR_GLOBAL	M239 Step Up uiSt3ServoHome	位	VAR_GLOBAL	M240 uiSt3StepHome	位	VAR_GLOBAL	M241 gSt3StepSafe	位	VAR_GLOBAL	M242 uiSt3Feed	位	VAR_GLOBAL	M243 gSt3Feed	位	VAR_GLOBAL	M244 gSt3NextPos	位	VAR_GLOBAL	M245 uiGetSt3ToolChk	位	VAR_GLOBAL	M246 gWaitStopAuto	位	VAR_GLOBAL	M247 uiSt1Vacuum	位	VAR_GLOBAL	M248 uiSt5Air2	位	VAR_GLOBAL	M249 gSt1Vacuum	位	VAR_GLOBAL	M250 gSt5Air2	位	VAR_GLOBAL	M251 gSimulate	位	VAR_GLOBAL	M252 uiSt3GoSafeHeight	位	VAR_GLOBAL	M253 gSt3GoSafeHeight	位	VAR_GLOBAL	M254 uiResetAllSt	位	VAR_GLOBAL	M255 St3CanPick	位	VAR_GLOBAL	M256 gSt1CanPick	位	VAR_GLOBAL	M258 gSt5CanPick	位	VAR_GLOBAL	M259 gAllAxisCanMove	位	VAR_GLOBAL	M260 gRotateArrived	位	VAR_GLOBAL	M261 Rotate Table Arrived gBuzzerEnable	位	VAR_GLOBAL	M262 gClearTool	位	VAR_GLOBAL	M263 gAllStCycleDone	位	VAR_GLOBAL	M264 gCalcCycleTime	位	VAR_GLOBAL	M265 gTargetCounted	位	VAR_GLOBAL	M266 gAutoCanGoNext	位	VAR_GLOBAL	M267 manRotate	位	VAR_GLOBAL	M268 gSt1PF	位	VAR_GLOBAL	M269 gSt1LF	位	VAR_GLOBAL	M270 gSt5PF	位	VAR_GLOBAL	M271 gSt5LF	位	VAR_GLOBAL	M272 uiSt5VacuumBreak	位	VAR_GLOBAL	M273 gSt5VacuumBreak	位	VAR_GLOBAL	M274 St7ResultOK	位	VAR_GLOBAL	M275 uiSt5SquareVacuum	位	VAR_GLOBAL	M276 Zebra Square Vacuum gSt5SquareVacuum	位	VAR_GLOBAL	M277 St8NeedGet	位	VAR_GLOBAL St8GetDone	位	VAR_GLOBAL a1Speed	双字[有符号]	VAR_GLOBAL a2Speed	双字[有符号]	VAR_GLOBAL wAutoIdx	字[有符号]	VAR_GLOBAL 0
wCycleTime	双字[无符号]/位串[32位]	VAR_GLOBAL	D150 wLastCycleTime	双字[无符号]/位串[32位]	VAR_GLOBAL	D152 wDataArray	字[有符号](0..9)	VAR_GLOBAL	D100 wAxisZeroIdx	字[有符号]	VAR_GLOBAL 0
tmrSysInit	TON	VAR_GLOBAL 0
gSt3NoTool	位	VAR_GLOBAL 0
gSt3NoToolTO	位	VAR_GLOBAL 0
tmrSt10Chk	TON	VAR_GLOBAL 0
gSt2HasTool	位	VAR_GLOBAL 0
gSt4HasTool	位	VAR_GLOBAL 0
tmrSt7WaitChk	TON	VAR_GLOBAL gSt3NextSide	字[有符号]	VAR_GLOBAL	D56 St3下一個工件是1-正或2-反或0-還沒檢查 gSt3CurIsBackSide	位	VAR_GLOBAL St8GoNg	位	VAR_GLOBAL 0
gSt3StepGoPos	位	VAR_GLOBAL 0
gClearDataArray	位	VAR_GLOBAL 0
st7HasTool	位	VAR_GLOBAL 0
st7ToolOk	位	VAR_GLOBAL 0
St1PutDone	位	VAR_GLOBAL 0
St3PutDone	位	VAR_GLOBAL 0
St5PutDone	位	VAR_GLOBAL 0
errDoorOpen	位	VAR_GLOBAL	F2 St2ContNG	位	VAR_GLOBAL St3ContNG	位	VAR_GLOBAL St4ContNG	位	VAR_GLOBAL St7ContNG	位	VAR_GLOBAL wSt2CountNG	字[有符号]	VAR_GLOBAL wSt3CountNG	字[有符号]	VAR_GLOBAL wSt4CountNG	字[有符号]	VAR_GLOBAL wSt7CountNG	字[有符号]	VAR_GLOBAL St3Done	位	VAR_GLOBAL 0
St6Done	位	VAR_GLOBAL 0
St7Done	位	VAR_GLOBAL 0
St9Done	位	VAR_GLOBAL 0
gSt3NeedCheck	位	VAR_GLOBAL 0
gA2JogN	位	VAR_GLOBAL 0
gA2JogP	位	VAR_GLOBAL 0
St3NextPosCount	字[有符号]	VAR_GLOBAL 0
wPageIndex	字[有符号]	VAR_GLOBAL uiStReset	位	VAR_GLOBAL 0
manSt1PF	位	VAR_GLOBAL 0
manSt1LF	位	VAR_GLOBAL 0 xSt3ServoOrg	位	VAR_GLOBAL	X0 0
xSt3StepPL	位	VAR_GLOBAL	X1 0
xSt3StepOrg	位	VAR_GLOBAL	X2 0
xSt3StepNL	位	VAR_GLOBAL	X3 0
xSt3ServoReady	位	VAR_GLOBAL	X6 0
xSt3ServoALM	位	VAR_GLOBAL	X7 0
xIndexOrg	位	VAR_GLOBAL	X10 0
xIndexAct	位	VAR_GLOBAL	X11 0
xEmg	位	VAR_GLOBAL	X12 0
xSt1LF_FeedIn	位	VAR_GLOBAL	X13 0
xSt1LF_Full	位	VAR_GLOBAL	X14 0
xSt1DownOrg	位	VAR_GLOBAL	X15 0
xSt1DownAct	位	VAR_GLOBAL	X16 0
xSt1ForwardOrg	位	VAR_GLOBAL	X17 0
xSt1ForwardAct	位	VAR_GLOBAL	X20 0
xSt1ClampRotateAct	位	VAR_GLOBAL	X21 0
xSt1ClampRotateOrg	位	VAR_GLOBAL	X22 0
xSt1SeperateOrg	位	VAR_GLOBAL	X23 0
xSt1SeperateAct	位	VAR_GLOBAL	X24 0
xSt2Check	位	VAR_GLOBAL	X25 0
xSt3FeedIn	位	VAR_GLOBAL	X27 0
xSt3CheckUpDown	位	VAR_GLOBAL	X30 Check front and back of workpiece 0
xSt3DownOrg	位	VAR_GLOBAL	X31 0
xSt3DownAct	位	VAR_GLOBAL	X32 0
xSt3ForwardOrg	位	VAR_GLOBAL	X33 0
xSt3ForwardAct	位	VAR_GLOBAL	X34 0
xSt3SuckOrg	位	VAR_GLOBAL	X35 0
xSt4Check	位	VAR_GLOBAL	X36 0
xSt5LF_FeedIn	位	VAR_GLOBAL	X37 0
xSt5LF_Full	位	VAR_GLOBAL	X40 0
xSt5CCDTrig	位	VAR_GLOBAL	X41 0
xSt7KeyenceOut1	位	VAR_GLOBAL	X42 有料	有料 0
xSt7KeyenceOut2	位	VAR_GLOBAL	X43 正面(ok)	正面(ok) 0
xSt5DownOrg	位	VAR_GLOBAL	X44 0
xSt5DownAct	位	VAR_GLOBAL	X45 0
xSt5ForwardOrg	位	VAR_GLOBAL	X46 0
xSt5ForwardAct	位	VAR_GLOBAL	X47 0
xSt5SeperateOrg	位	VAR_GLOBAL	X50 0
xSt5SeperateAct	位	VAR_GLOBAL	X51 xSt6DownOrg	位	VAR_GLOBAL	X52 xSt6DownAct	位	VAR_GLOBAL	X53 xSt7DownOrg	位	VAR_GLOBAL	X54 xSt7DownAct	位	VAR_GLOBAL	X55 xSt8DownOrg	位	VAR_GLOBAL	X56 xSt8DownAct	位	VAR_GLOBAL	X57 xSt8ForwardOrg	位	VAR_GLOBAL	X60 xSt8ForwardAct	位	VAR_GLOBAL	X61 xSt9UpOrg	位	VAR_GLOBAL	X62 xSt9UpAct	位	VAR_GLOBAL	X63 xSt10Check	位	VAR_GLOBAL	X64 xFrontDoor	位	VAR_GLOBAL	X65 xBackDoor	位	VAR_GLOBAL	X66 xSt5SuckOrg	位	VAR_GLOBAL	X67 ySt3ServoPulse	位	VAR_GLOBAL	Y0 ySt3StepPulse	位	VAR_GLOBAL	Y1 ySt3ServoDir	位	VAR_GLOBAL	Y4 ySt3StepDir	位	VAR_GLOBAL	Y5 yIndex	位	VAR_GLOBAL	Y10 ySt1PF	位	VAR_GLOBAL	Y11 ySt1LF	位	VAR_GLOBAL	Y12 ySt1Down	位	VAR_GLOBAL	Y13 ySt1Forward	位	VAR_GLOBAL	Y14 ySt1Clamp	位	VAR_GLOBAL	Y15 ySt1ClampRotate	位	VAR_GLOBAL	Y16 ySt1Seperate	位	VAR_GLOBAL	Y17 ySt3Down	位	VAR_GLOBAL	Y20 ySt3Forward	位	VAR_GLOBAL	Y21 ySt3Suck	位	VAR_GLOBAL	Y22 ySt5PF	位	VAR_GLOBAL	Y23 ySt5LF	位	VAR_GLOBAL	Y24 ySt5Down	位	VAR_GLOBAL	Y25 ySt5Forward	位	VAR_GLOBAL	Y26 ySt5SquareVacuum	位	VAR_GLOBAL	Y27 ySt5Seperate	位	VAR_GLOBAL	Y30 ySt6Down	位	VAR_GLOBAL	Y31 ySt7Down	位	VAR_GLOBAL	Y32 ySt8Down	位	VAR_GLOBAL	Y33 ySt8Forward	位	VAR_GLOBAL	Y34 ySt8Clamp	位	VAR_GLOBAL	Y35 ySt9Up	位	VAR_GLOBAL	Y36 ySt9BlowAir	位	VAR_GLOBAL	Y37 ySt3Ccd1	位	VAR_GLOBAL	Y44 ySt3Ccd2	位	VAR_GLOBAL	Y45 yLight	位	VAR_GLOBAL	Y46 ySt3ServoServoOn	位	VAR_GLOBAL	Y52 ySt3ServoServoBrake	位	VAR_GLOBAL	Y53 ySt1Vacuum	位	VAR_GLOBAL	Y54 ySt5VacuumBreak	位	VAR_GLOBAL	Y55 ySt5Vacuum	位	VAR_GLOBAL	Y56 Declare
calcA1Speed	位	VAR calcA2Speed	位	VAR a2HadDone	位	VAR axis2ZeroIdx	字[有符号]	VAR axis1ZeroIdx	字[有符号]	VAR tmpBool	位	VAR st3NextPosIdx	字[有符号]	VAR manSt5PF	位	VAR manSt5LF	位	VAR st3StepGoPosIdx	字[有符号]	VAR idx	字[有符号]	VAR tmrWaitLetAxis2Down	TON	VAR Code
tmrSysInit(IN := SM8000, PT:= t#10s); sys.EMG := NOT xEmg OR F0; IF NOT tmrSysInit.Q THEN RETURN;
END_IF; IF sys.EMG THEN gSt3NextSide := 0; SET(TRUE, gSt3NeedCheck);
END_IF; IF LDP(TRUE, sys.ManMode) THEN RST(TRUE, St1PutDone); RST(TRUE, St3Done); RST(TRUE, St5PutDone); RST(TRUE, St6Done); RST(TRUE, St7Done); RST(TRUE, St8GetDone); RST(TRUE, St8NeedGet); RST(TRUE, gSt1Seperate); RST(TRUE, gSt5Seperate); RST(TRUE, St8GetDone);
END_IF; ALTP(uiLight, yLight); gAutoCanGoNext := NOT sys.HasError; gCanChangePage := gAllStCanCycle; tmrSt10Chk(IN:=xSt10Check AND gRotateArrived, PT:=T#0.5s);
IF gRotateArrived THEN IF tmrSt10Chk.Q THEN SET(TRUE, F3); END_IF;
END_IF; IF ((uiStartAuto AND (NOT sys.AutoMode)) OR gClearTool) AND NOT F3 THEN IF NOT sys.HasError AND NOT gWaitStopAuto AND gAllStCanCycle AND NOT F6 AND NOT F7 THEN SET(TRUE, sys.AutoMode); RST(TRUE, sys.ManMode); END_IF;
END_IF; SET(sys.AutoMode AND uiStopAuto AND NOT gWaitStopAuto, gWaitStopAuto);
RST(sys.AutoMode AND uiStopAuto AND gClearTool, gClearTool); IF uiClearTool AND NOT F3 THEN IF CheckHasTool(wDataArray) THEN SET(TRUE, gClearTool); END_IF;
END_IF; gAllStCycleDone := (NOT St1Cycle OR St1PutDone) AND (NOT St3Cycle(* OR St3Done*)) AND (NOT St5Cycle OR St5PutDone) AND ((NOT UseSt6) OR (UseSt6 AND NOT St6Cycle)) AND NOT St7Cycle AND (NOT St8NeedGet OR (St8NeedGet AND St8GetDone)) AND NOT St9Cycle; gAllStCanCycle := St1InOrg AND St3InOrg AND St5InOrg AND ((NOT UseSt6) OR (UseSt6 AND St6InOrg)) AND //St7InOrg AND St8InOrg AND St9InOrg; gLight.Yellow := F54 OR F55 OR F56 OR F57; gLight.Green := (sys.ManMode AND SM8013) OR (sys.AutoMode); gLight.Red := SM8013 AND (sys.EMG OR sys.HasError OR sys.HasWarning); gBuzzerEnable := NOT uiEnBuzzer;
gLight.Buzzer := gBuzzerEnable AND SM8013 AND (sys.HasWarning OR sys.HasError); IF manRotate THEN SET(TRUE, gRotate); RST(TRUE, manRotate);
END_IF; IF LDP(TRUE, uiFeeder) THEN SET(TRUE, gSt1RotatoryFeeder); SET(TRUE, gSt5RotatoryFeeder); SET(gAllAxisZeroDone AND gA1IO.xReady, gSt3Feed);
END_IF; IF LDF(TRUE, uiFeeder) THEN RST(TRUE, gSt1RotatoryFeeder); RST(TRUE, gSt5RotatoryFeeder); RST(TRUE, gSt3Feed); RST(TRUE, gSt1Vacuum); RST(TRUE, gSt5SquareVacuum);
END_IF; IF gClearDataArray THEN FOR idx := 0 TO 9 BY 1 DO wDataArray[idx] := 0; END_FOR; RST(TRUE, gClearDataArray);
END_IF; RotateTable( iOrigPos:= xIndexOrg, iActPos:= xIndexAct, iRun:= gRotate AND (NOT sys.Error), iRotateTO:= wRotateTO, iInPosWaitTime:= wRotateOnPosWaitT, iReset := ResetAlarm, oDevice =&gt; yIndex); RST(RotateTable.oBusy, gRotate); SET(LDP(TRUE, RotateTable.oArrived), gRotateArrived); // cylinder function block control
cySt1Down( iAct := gSt1Down, iRst := ResetAlarm, iLimit1 := xSt1DownOrg, iLimit2 := xSt1DownAct, oDevice =&gt;ySt1Down, iOnTO := wSt1DownTO, iOffTO := wSt1DownTO, iOnDelay := wSt1DownOnT, iOffDelay := wSt1DownOffT); cySt1Forward( iAct := gSt1Forward, iRst := ResetAlarm, iLimit1 := xSt1ForwardOrg, iLimit2 := xSt1ForwardAct, oDevice =&gt;ySt1Forward, iOnTO := wSt1ForwardTO, iOffTO := wSt1ForwardTO, iOnDelay := wSt1ForwardOnT, iOffDelay := wSt1ForwardOffT); cySt1Clamp( iAct := gSt1Clamp, oDevice =&gt;ySt1Clamp, iOnDelay := wSt1ClampOnT, iOffDelay := wSt1ClampOffT); cySt1ClampRotate( iAct := gSt1ClampRotate, iRst := ResetAlarm, iLimit1 := xSt1ClampRotateOrg, iLimit2 := xSt1ClampRotateAct, oDevice =&gt;ySt1ClampRotate, iOnTO := wSt1ClampRotateTO, iOffTO := wSt1ClampRotateTO, iOnDelay := wSt1ClampRotateOnT, iOffDelay := wSt1ClampRotateOffT); cySt1Seperate( iAct := gSt1Seperate, iRst := ResetAlarm, iLimit1 := xSt1SeperateOrg, iLimit2 := xSt1SeperateAct, oDevice =&gt;ySt1Seperate, iOnTO := wSt1SeperateTO, iOffTO := wSt1SeperateTO, iOnDelay := wSt1SeperateOnT, iOffDelay := wSt1SeperateOffT); cySt3Down( iAct := gSt3Down, iRst := ResetAlarm, iLimit1 := xSt3DownOrg, iLimit2 := xSt3DownAct, oDevice =&gt;ySt3Down, iOnTO := wSt3DownTO, iOffTO := wSt3DownTO, iOnDelay := wSt3DownOnT, iOffDelay := wSt3DownOffT); cySt3Forward( iAct := gSt3Forward, iRst := ResetAlarm, iLimit1 := xSt3ForwardOrg, iLimit2 := xSt3ForwardAct, oDevice =&gt;ySt3Forward, iOnTO := wSt3ForwardTO, iOffTO := wSt3ForwardTO, iOnDelay := wSt3ForwardOnT, iOffDelay := wSt3ForwardOffT); cySt3Suck( iAct := gSt3Suck, iRst := ResetAlarm, iLimit1 := xSt3SuckOrg, oDevice =&gt; ySt3Suck, iOnDelay := wSt3SuckOnT, iOffDelay := wSt3SuckOffT, iOnTO := wSt3SuckTO, iOffTO := wSt3SuckTO); cySt5Suck( iAct := gSt5Suck, iRst := ResetAlarm, iLimit1 := xSt5SuckOrg, //oDevice =&gt; ySt5Suck, oDevice =&gt; ySt5Vacuum, iOnDelay := wSt5SuckOnT, iOffDelay := wSt5SuckOffT, iOnTO := wSt5SuckTO, iOffTO := wSt5SuckTO); cySt5Down( iAct := gSt5Down, iRst := ResetAlarm, iLimit1 := xSt5DownOrg, iLimit2 := xSt5DownAct, oDevice =&gt;ySt5Down, iOnTO := wSt5DownTO, iOffTO := wSt5DownTO, iOnDelay := wSt5DownOnT, iOffDelay := wSt5DownOffT); cySt5Forward( iAct := gSt5Forward, iRst := ResetAlarm, iLimit1 := xSt5ForwardOrg, iLimit2 := xSt5ForwardAct, oDevice =&gt;ySt5Forward, iOnTO := wSt5ForwardTO, iOffTO := wSt5ForwardTO, iOnDelay := wSt5ForwardOnT, iOffDelay := wSt5ForwardOffT); cySt5Seperate( iAct := gSt5Seperate, iRst := ResetAlarm, iLimit1 := xSt5SeperateOrg, iLimit2 := xSt5SeperateAct, oDevice =&gt;ySt5Seperate, iOnTO := wSt5SeperateTO, iOffTO := wSt5SeperateTO, iOnDelay := wSt5SeperateOnT, iOffDelay := wSt5SeperateOffT); cySt6Down( iAct := gSt6Down, iRst := ResetAlarm, iLimit1 := xSt6DownOrg, iLimit2 := xSt6DownAct, oDevice =&gt;ySt6Down, iOnTO := wSt6DownTO, iOffTO := wSt6DownTO, iOnDelay := wSt6DownOnT, iOffDelay := wSt6DownOffT); (*cySt7Down( iAct := gSt7Down, iRst := gResetAlarm, iLimit1 := xSt7DownOrg, iLimit2 := xSt7DownAct, oDevice =&gt;ySt7Down, iOnTO := wSt7DownTO, iOffTO := wSt7DownTO, iOnDelay := wSt7DownOnT, iOffDelay := wSt7DownOffT);*) cySt8Down( iAct := gSt8Down, iRst := ResetAlarm, iLimit1 := xSt8DownOrg, iLimit2 := xSt8DownAct, oDevice =&gt;ySt8Down, iOnTO := wSt8DownTO, iOffTO := wSt8DownTO, iOnDelay := wSt8DownOnT, iOffDelay := wSt8DownOffT); cySt8Forward( iAct := gSt8Forward, iRst := ResetAlarm, iLimit1 := xSt8ForwardOrg, iLimit2 := xSt8ForwardAct, oDevice =&gt;ySt8Forward, iOnTO := wSt8ForwardTO, iOffTO := wSt8ForwardTO, iOnDelay := wSt8ForwardOnT, iOffDelay := wSt8ForwardOffT); cySt8Clamp( iAct := gSt8Clamp, oDevice =&gt;ySt8Clamp, iOnDelay := wSt8ClampOnT, iOffDelay := wSt8ClampOffT); cySt9Up( iAct := gSt9Up, iRst := ResetAlarm, iLimit1 := xSt9UpOrg, iLimit2 := xSt9UpAct, oDevice =&gt;ySt9Up, iOnTO := wSt9UpTO, iOffTO := wSt9UpTO, iOnDelay := wSt9UpOnT, iOffDelay := wSt9UpOffT); cySt9BlowAir( iAct := gSt9BlowAir, oDevice =&gt;ySt9BlowAir, iOnDelay := wSt9BlowAirOnT, iOffDelay := wSt9BlowAirOffT); rfSt1( iAct:= gSt1RotatoryFeeder AND NOT ResetAlarm,	(* 當送料逾時時，重置可重新計數時間 *) iFull:= xSt1LF_Full, iArrived:= xSt1LF_FeedIn, iFullOnT:= wSt1FullOnT, iFullOffT:= wSt1FullOffT, iArrivedOnT:= wSt1FeedInOnT, oCanPick =&gt; gSt1CanPick, oFeeder =&gt; gSt1PF, oLinearFeeder =&gt; gSt1LF, iSupplyTO:= wSt1FullTO, iArriveTO:= wSt1FeedInTO); IF LDP(TRUE, gSt1CanPick) THEN SET(TRUE, gSt1Vacuum); END_IF; ySt1PF := gSt1PF OR (manSt1PF AND sys.ManMode); ySt1LF := gSt1LF OR (manSt1LF AND sys.ManMode); rfSt5( iAct:= gSt5RotatoryFeeder AND NOT ResetAlarm, iFull:= xSt5LF_Full, iArrived:= xSt5LF_FeedIn, iFullOnT:= wSt5FullOnT, iFullOffT:= wSt5FullOffT, iArrivedOnT:= wSt5FeedInOnT, oCanPick =&gt; gSt5CanPick, oFeeder =&gt; gSt5PF, oLinearFeeder =&gt; gSt5LF, iSupplyTO:= wSt5FullTO, iArriveTO:= wSt5FeedInTO); ySt5PF := gSt5PF OR (manSt5PF AND sys.ManMode);
ySt5LF := gSt5LF OR (manSt5LF AND sys.ManMode); ySt1Vacuum := gSt1Vacuum;
ySt5VacuumBreak := gSt5VacuumBreak; ySt5SquareVacuum := gSt5SquareVacuum; Declare
autoGoNext	位 idx	字[有符号] Code IF NOT tmrSysInit.Q THEN RETURN;
END_IF; SET(NOT xBackDoor AND NOT ResetAlarm, errDoorOpen); IF LDP(TRUE, sys.AutoMode) THEN wAutoIdx := 10; SET(TRUE, uiFeeder);
END_IF; IF NOT sys.AutoMode THEN RETURN;
END_IF; IF NOT errDoorOpen THEN IF gCalcCycleTime AND LDP(TRUE, SM8012) THEN wCycleTime := wCycleTime + 1; END_IF;
END_IF; CASE wAutoIdx OF
10: (* rotate plate *) SET(TRUE, gRotate); RST(TRUE, gRotateArrived); SET(TRUE, autoGoNext);
20: IF RotateTable.oBusy THEN RST(TRUE, gRotate); // shift data FOR idx := 1 TO 9 BY 1 DO wDataArray[10-idx] := wDataArray[9-idx]; END_FOR; wDataArray[0] := 0; SET(TRUE, autoGoNext); ELSIF RotateTable.oErr THEN wAutoIdx := NG_STEP; END_IF;
30: // index table rotating, check which station should act. // station 1 IF NOT gClearTool THEN wDataArray[0] := 10; SET(NOT gClearTool, autoSt1Cycle); END_IF; // station 3 IF (wDataArray[2] = (20+ STEP_OK)) THEN SET(TRUE, autoSt3Cycle); END_IF; // station 5 SET(wDataArray[4] = (40+STEP_OK), autoSt5Cycle); SET(TRUE, autoGoNext);
40: // index table arrived, check which station should act. IF gRotateArrived THEN // station 6 IF wDataArray[5] = (50+STEP_OK) THEN IF UseSt6 THEN SET(TRUE, autoSt6Cycle); ELSE wDataArray[5] := 60+STEP_OK; END_IF; END_IF; // station 8 - ok IF wDataArray[7] = (70+STEP_OK) OR St7ResultOK THEN RST(TRUE, St7ResultOK); RST(TRUE, St8GetDone); SET(TRUE, St8NeedGet); ELSE RST(TRUE, St8NeedGet); END_IF; // station 9 - ng IF (wDataArray[8] &gt;= TOOL_NG) THEN SET(TRUE, autoSt9Cycle); END_IF; SET(TRUE, autoGoNext); END_IF;
50: IF gAllStCycleDone THEN IF St1PutDone THEN wDataArray[0] := 10+STEP_OK; END_IF; //IF gSt2HasTool THEN IF xSt2Check THEN wDataArray[1] := 20+STEP_OK; END_IF; IF St3Done THEN IF gSt3CurIsBackSide THEN wDataArray[2] := 903; wSt3CountNG := wSt3CountNG + 1; ELSE wDataArray[2] := 30+STEP_OK; wSt3CountNG := 0; END_IF; IF wSt3CountNG &gt;= CONTINUS_NG_TARGET THEN SET(TRUE, St3ContNG); ELSE RST(TRUE, St3ContNG); END_IF; RST(TRUE, gSt3CurIsBackSide); END_IF; (* station 4 *) IF (wDataArray[3] = (30+STEP_OK)) THEN //IF gSt4HasTool THEN IF xSt4Check THEN wDataArray[3] := 40+STEP_OK; wSt4CountNG := 0; ELSE wDataArray[3] := 904; wSt4CountNG := wSt4CountNG + 1; END_IF; IF wSt4CountNG &gt;= CONTINUS_NG_TARGET THEN SET(TRUE, St4ContNG); ELSE RST(TRUE, St4ContNG); END_IF; END_IF; IF St5PutDone THEN wDataArray[4] := 50+STEP_OK; END_IF; IF St6Done THEN wDataArray[5] := 60+STEP_OK; END_IF; (* station 7 *) IF (wDataArray[6] = (60+STEP_OK)) THEN IF st7HasTool AND st7ToolOk THEN SET(TRUE, St7ResultOK); ELSE RST(TRUE, St7ResultOK); END_IF; IF St7ResultOK THEN wDataArray[6] := 70+STEP_OK; wSt7CountNG := 0; ELSE wDataArray[6] := 907; wSt7CountNG := wSt7CountNG + 1; END_IF; IF wSt7CountNG &gt;= CONTINUS_NG_TARGET THEN SET(TRUE, St7ContNG); ELSE RST(TRUE, St7ContNG); END_IF; END_IF; IF St8GetDone THEN wDataArray[7] := 0; wProductOkCount := wProductOkCount + 1; wTotalOkCnt := wTotalOkCnt + 1; END_IF; IF St9Done THEN wDataArray[8] := 0; wProductNgCount := wProductNgCount + 1; END_IF; RST(TRUE, St1PutDone); RST(TRUE, St3Done); RST(TRUE, St5PutDone); RST(TRUE, St6Done); RST(TRUE, St7Done); RST(TRUE, St8GetDone); RST(TRUE, St9Done); RST(TRUE, St8NeedGet); IF gEnStopCount THEN IF wProductOkCount &gt;= wStopMachineNumber THEN SET(TRUE, gTargetCounted); SET(TRUE, gWaitStopAuto); END_IF; END_IF; IF gClearTool THEN IF CheckHasTool(wDataArray) = FALSE THEN RST(TRUE, gClearTool); SET(TRUE, gWaitStopAuto); END_IF; END_IF; wAutoIdx := 60; END_IF;	// all cycle done
60: // non resident and non target counted IF (NOT F3) AND (NOT F4) AND NOT St3ContNG AND NOT St4ContNG AND NOT St7ContNG THEN IF NOT gWaitStopAuto THEN wAutoIdx := 10; ELSE wAutoIdx := OK_STEP; END_IF; END_IF;
END_CASE; IF St8NeedGet AND (NOT St8GetDone) AND gRotateArrived AND (NOT St8Cycle) THEN SET(TRUE, autoSt8Cycle);
END_IF; IF wAutoIdx = OK_STEP THEN wAutoIdx := 0; RST(TRUE, sys.AutoMode); SET(TRUE, sys.ManMode); RST(TRUE, gWaitStopAuto); RST(TRUE, uiFeeder); RST(gClearTool, gClearTool); ELSIF wAutoIdx = NG_STEP THEN IF gAutoCanGoNext THEN wAutoIdx := 0; END_IF;
END_IF; IF autoGoNext THEN IF gAutoCanGoNext THEN wAutoIdx := wAutoIdx + 10; RST(TRUE, autoGoNext); END_IF;
END_IF; Declare Code IF NOT tmrSysInit.Q THEN RETURN;
END_IF; ResetAlarm := uiResetAlarm;
BKRSTP(ResetAlarm, 100, F0); sys.HasError := F0 OR F1 OR // F2 errDoorOpen OR // F3 OR F4 OR F5 OR F6 OR F7 ; sys.HasWarning := SM8048; IF sys.EMG THEN RST(TRUE, sys.AutoMode); SET(TRUE, sys.ManMode); RST(TRUE, gWaitStopAuto); RST(TRUE, gClearTool); RST(TRUE, gSt1RotatoryFeeder); RST(TRUE, gSt5RotatoryFeeder); RST(TRUE, gSt3Feed); RST(TRUE, gSt1Vacuum); RST(TRUE, uiFeeder); RST(TRUE, St1Cycle); RST(TRUE, St3Cycle); RST(TRUE, St5Cycle); RST(TRUE, St6Cycle); RST(TRUE, St7Cycle); RST(TRUE, St8Cycle); RST(TRUE, St9Cycle); RST(TRUE, gAllAxisZeroDone);
END_IF; IF ResetAlarm THEN IF St2ContNG THEN wSt2CountNG := 0; END_IF; IF St3ContNG THEN wSt3CountNG := 0; END_IF; IF St4ContNG THEN wSt4CountNG := 0; END_IF; IF St7ContNG THEN wSt7CountNG := 0; END_IF; RST(TRUE, St3ContNG); RST(TRUE, St4ContNG); RST(TRUE, St7ContNG);
ELSE SET(St3ContNG, F58); SET(St4ContNG, F59); SET(St7ContNG, F63); SET(sys.EMG, F0); SET(RotateTable.oErr, F1); IF gEnStopCount AND gTargetCounted THEN SET(TRUE, F4); RST(TRUE, gTargetCounted); END_IF; SET(NOT X26, F5); SET(NOT gA1ZeroDone, F6); SET(NOT gA2ZeroDone, F7); IF cySt1Down.oErr THEN SET(cySt1Down.oErrId = ErrCyOn, F10); SET(cySt1Down.oErrId = ErrCyOff, F11); SET(cySt1Down.oErrId = ErrCyBoth, F12); END_IF; IF cySt1Forward.oErr THEN SET(cySt1Forward.oErrId = ErrCyOn, F13); SET(cySt1Forward.oErrId = ErrCyOff, F14); SET(cySt1Forward.oErrId = ErrCyBoth, F15); END_IF; IF cySt1ClampRotate.oErr THEN SET(cySt1ClampRotate.oErrId = ErrCyOn, F16); SET(cySt1ClampRotate.oErrId = ErrCyOff, F17); SET(cySt1ClampRotate.oErrId = ErrCyBoth, F18); END_IF; IF cySt1Seperate.oErr THEN SET(cySt1Seperate.oErrId = ErrCyOn, F19); SET(cySt1Seperate.oErrId = ErrCyOff, F20); SET(cySt1Seperate.oErrId = ErrCyBoth, F21); END_IF; IF cySt3Down.oErr THEN SET(cySt3Down.oErrId = ErrCyOn, F22); SET(cySt3Down.oErrId = ErrCyOff, F23); SET(cySt3Down.oErrId = ErrCyBoth, F24); END_IF; IF cySt3Forward.oErr THEN SET(cySt3Forward.oErrId = ErrCyOn, F25); SET(cySt3Forward.oErrId = ErrCyOff, F26); SET(cySt3Forward.oErrId = ErrCyBoth, F27); END_IF; SET(cySt3Suck.oErr, F28); IF cySt5Down.oErr THEN SET(cySt5Down.oErrId = ErrCyOn, F29); SET(cySt5Down.oErrId = ErrCyOff, F30); SET(cySt5Down.oErrId = ErrCyBoth, F31); END_IF; IF cySt5Forward.oErr THEN SET(cySt5Forward.oErrId = ErrCyOn, F32); SET(cySt5Forward.oErrId = ErrCyOff, F33); SET(cySt5Forward.oErrId = ErrCyBoth, F34); END_IF; SET(cySt5Suck.oErr, F35); IF cySt5Seperate.oErr THEN SET(cySt5Seperate.oErrId = ErrCyOn, F36); SET(cySt5Seperate.oErrId = ErrCyOff, F37); SET(cySt5Seperate.oErrId = ErrCyBoth, F38); END_IF; IF cySt6Down.oErr THEN SET(cySt6Down.oErrId = ErrCyOn, F39); SET(cySt6Down.oErrId = ErrCyOff, F40); SET(cySt6Down.oErrId = ErrCyBoth, F41); END_IF; IF cySt7Down.oErr THEN SET(cySt7Down.oErrId = ErrCyOn, F42); SET(cySt7Down.oErrId = ErrCyOff, F43); SET(cySt7Down.oErrId = ErrCyBoth, F44); END_IF; IF cySt8Down.oErr THEN SET(cySt8Down.oErrId = ErrCyOn, F45); SET(cySt8Down.oErrId = ErrCyOff, F46); SET(cySt8Down.oErrId = ErrCyBoth, F47); END_IF; IF cySt8Forward.oErr THEN SET(cySt8Forward.oErrId = ErrCyOn, F48); SET(cySt8Forward.oErrId = ErrCyOff, F49); SET(cySt8Forward.oErrId = ErrCyBoth, F50); END_IF; IF cySt9Up.oErr THEN SET(cySt9Up.oErrId = ErrCyOn, F51); SET(cySt9Up.oErrId = ErrCyOff, F52); SET(cySt9Up.oErrId = ErrCyBoth, F53); END_IF; IF gSt1RotatoryFeeder THEN SET(rfSt1.oArriveTO, F54); SET(rfSt1.oNeedSupply, F55); END_IF; IF gSt5RotatoryFeeder THEN SET(rfSt5.oArriveTO, F56); SET(rfSt5.oNeedSupply, F57); END_IF;
END_IF; IF (NOT tmrSysInit.Q) OR sys.EMG OR (NOT sys.ManMode) THEN RETURN;
END_IF; DMOV(uiRstOkCnt, 0, wProductOkCount);
DMOV(uiRstNgCnt, 0, wProductNgCount);
DMOV(uiRstTotalOkCnt, 0, wTotalOkCnt); IF uiResetAllSt THEN SET(TRUE, uiSt1Reset); SET(TRUE, uiSt3Reset); SET(TRUE, uiSt5Reset); SET(TRUE, uiSt6Reset); SET(TRUE, uiSt7Reset); SET(TRUE, uiSt8Reset); SET(TRUE, uiSt9Reset);
END_IF; CASE wPageIndex OF 11: IF NOT St1Cycle THEN ALTP(M50 AND cySt1Seperate.oOn, gSt1Down); ALTP(M51 AND cySt1Down.oOff, gSt1Forward); ALTP(M52, gSt1Clamp); ALTP(M53, gSt1ClampRotate); ALTP(M54, gSt1Seperate); ALTP(M55, gSt1Vacuum); END_IF; SET(uiStReset, uiSt1Reset);
13: IF NOT St3Cycle THEN ALTP(M50, gSt3Down); ALTP(M51 AND cySt3Down.oOff, gSt3Forward); ALTP(M52, gSt3Suck); ALTP(M53, gSt3GoSafeHeight); END_IF; END_CASE; // can change page
M81 := (wPageIndex=11 AND St1Cycle) OR (wPageIndex=13 AND St3Cycle) OR SM8001; IF uiSt1Reset THEN RST(TRUE, gSt1Down); RST(TRUE, gSt1Forward); RST(TRUE, gSt1Clamp); RST(TRUE, gSt1ClampRotate); RST(TRUE, gSt1Seperate); RST(TRUE, St1Cycle); RST(TRUE, manSt1PF); RST(TRUE, manSt1LF); RST(TRUE, gSt1PF); RST(TRUE, gSt1LF); RST(TRUE, gSt1Vacuum); RST(TRUE, uiSt1Reset);
END_IF; IF uiSt3Reset THEN RST(TRUE, gSt3Down); RST(TRUE, gSt3Forward); RST(TRUE, gSt3Suck); RST(TRUE, gSt3GoSafeHeight); RST(TRUE, St3Cycle); RST(TRUE, gSt3Feed); RST(TRUE, uiSt3Reset);
END_IF; canGoNext	位 goNext	位 goNg	位 ; IF St1Cycle THEN IF wSt1Index = OK_STEP THEN St1Cycle := FALSE; wSt1Index := 0; ELSIF wSt1Index = NG_STEP THEN IF canGoNext THEN wSt1Index := wSt1LastIndex; wSt1LastIndex := 0; END_IF; END_IF; IF sys.AutoMode THEN SET(gSt1CanPick AND NOT gSt1Seperate, gSt1Seperate); END_IF; CASE wSt1Index OF 10: IF sys.AutoMode THEN wDataArray[0] := 10 + STEP_BUSY; END_IF; IF NOT F54 THEN SET(gSt1CanPick OR sys.ManMode, gSt1Seperate); END_IF; IF cySt1Seperate.oOn THEN goNext := TRUE; ELSIF cySt1Seperate.oErr THEN RST(TRUE, gSt1Seperate); goNg := TRUE; END_IF; 20: gSt1Down := TRUE; IF cySt1Down.oOn THEN goNext := TRUE; ELSIF cySt1Down.oErr THEN gSt1Down := FALSE; goNg := TRUE; END_IF; 30: gSt1Clamp := TRUE; IF cySt1Clamp.oOn THEN RST(TRUE, gSt1Vacuum); goNext := TRUE; END_IF; 40:	// up gSt1Down := FALSE; IF cySt1Down.oOff THEN RST(TRUE, gSt1Seperate); goNext := TRUE; ELSIF cySt1Down.oErr THEN goNg := TRUE; END_IF; 50:	// rotate, forward gSt1ClampRotate := TRUE; gSt1Forward := TRUE; IF cySt1ClampRotate.oOn THEN goNext := TRUE; ELSIF cySt1ClampRotate.oErr THEN gSt1Forward := FALSE; goNg := TRUE; END_IF; 60:	// forward goNext := TRUE; gSt1Forward := TRUE; IF cySt1Forward.oOn THEN goNext := TRUE; ELSIF cySt1Forward.oErr THEN gSt1Forward := FALSE; goNg := TRUE; END_IF; 70:	// down IF sys.ManMode THEN SET(TRUE, gSt1Down); ELSIF sys.AutoMode THEN SET(gRotateArrived, gSt1Down); END_IF; IF cySt1Down.oOn THEN goNext := TRUE; ELSIF cySt1Down.oErr THEN RST(TRUE, gSt1Down); goNg := TRUE; END_IF; 80:	// clamp off gSt1Clamp := FALSE; SET(cySt1Clamp.oOff, goNext); 90:	// up gSt1Down := FALSE; IF cySt1Down.oOff THEN SET(TRUE, St1PutDone); goNext := TRUE; ELSIF cySt1Down.oErr THEN goNg := TRUE; END_IF; 100:// back gSt1Forward := FALSE; gSt1ClampRotate := FALSE; IF cySt1Forward.oOff AND cySt1ClampRotate.oOff THEN goNext := TRUE; ELSIF cySt1Forward.oErr THEN goNg := TRUE; END_IF; 110: wSt1Index := OK_STEP; END_CASE; IF goNg THEN wSt1LastIndex := wSt1Index; wSt1Index := NG_STEP; goNg := FALSE; END_IF; IF goNext AND canGoNext THEN wSt1Index := wSt1Index + 10; goNext := FALSE; END_IF;
END_IF; St1InOrg := cySt1Down.oOff AND cySt1Forward.oOff AND cySt1Clamp.oOff AND cySt1ClampRotate.oOff AND SM8000; canGoNext := NOT sys.HasError AND NOT cySt1Down.oErr AND NOT cySt1Forward.oErr AND NOT cySt1ClampRotate.oErr AND NOT cySt1Seperate.oErr AND SM8000;
st3WaitChk	位 tmrSt3ChkUpDown	TON st3Sucking	位 tmrSt3Vibrat1	TON	振動啟始時間
tmrSt3Vibrat2	TON	振動時間
st3Vibrat1	位 st3Vibrat2	位 goNext	位 canGoNext	位 goNg	位 ;
(* TODO: 過程中吸失敗，繼續做完，並判定為不良品 *) IF St3Cycle THEN IF wSt3Index = OK_STEP THEN SET(TRUE, St3Done); St3Cycle := FALSE; wSt3Index := 0; ELSIF wSt3Index = NG_STEP THEN IF canGoNext THEN IF wSt3LastIndex = 30 AND cySt3Suck.oErr THEN wSt3Index := 20; ELSE wSt3Index := wSt3LastIndex; wSt3LastIndex := 0; END_IF; END_IF; END_IF; CASE wSt3Index OF 10: IF St3CanPick OR (gSt3NextPos AND gRotateArrived) THEN IF sys.AutoMode THEN wDataArray[2] := 30 + STEP_BUSY; END_IF; RST(TRUE, gSt3CurIsBackSide); IF (gSt3NextSide = 0) OR gSt3NeedCheck THEN wSt3Index := 200; RST(TRUE, gSt3NeedCheck); ELSE SET(TRUE, goNext); END_IF; END_IF; 20:	// suck and down IF St3CanPick AND cySt3Forward.oOff THEN gSt3Down := TRUE; gSt3Suck := TRUE; St3NextPosCount := 0; END_IF; RST(TRUE, st3Vibrat1); RST(TRUE, st3Vibrat2); (* 如果這一次要取的料是反面，設定此旗標 *) SET(gSt3NextSide = 2, gSt3CurIsBackSide); IF (cySt3Suck.oOn OR sys.ManMode) AND cySt3Down.oOn THEN //St3GoNext := TRUE; wSt3Index := 21; ELSIF cySt3Suck.oErr AND sys.AutoMode THEN RST(TRUE, gSt3Down); RST(TRUE, gSt3Suck); SET(TRUE, goNg); END_IF; 21: RST(TRUE, gSt3Down); SET(TRUE, st3Vibrat1); IF tmrSt3Vibrat1.Q THEN wSt3Index := 22; SET(TRUE, gSt3Down); RST(TRUE, st3Vibrat1); END_IF; 22: SET(TRUE, st3Vibrat2); IF tmrSt3Vibrat2.Q THEN RST(TRUE, gSt3Down); RST(TRUE, st3Vibrat2); wSt3Index := 30; END_IF; 30:	// up RST(TRUE, gSt3Down); SET(TRUE, st3Sucking); IF cySt3Down.oOff THEN goNext := TRUE; ELSIF cySt3Down.oErr OR cySt3Suck.oErr THEN RST(cySt3Suck.oErr, gSt3Suck); SET(TRUE, goNg); END_IF; 40:	// forward gSt3Forward := TRUE; st3WaitChk := FALSE; IF cySt3Forward.oOn THEN goNext := TRUE; ELSIF cySt3Forward.oErr OR cySt3Suck.oErr THEN RST(cySt3Suck.oErr, gSt3Suck); SET(TRUE, goNg); END_IF; 50:	// down IF sys.ManMode THEN gSt3Down := TRUE; ELSIF sys.AutoMode THEN SET(gRotateArrived, gSt3Down); END_IF; IF cySt3Down.oOn THEN st3WaitChk := TRUE; goNext := TRUE; ELSIF cySt3Down.oErr OR cySt3Suck.oErr THEN goNg := TRUE; END_IF; 60:	// place down gSt3Suck := FALSE; IF cySt3Suck.oOff AND tmrSt3ChkUpDown.Q THEN RST(TRUE, st3Sucking); goNext := TRUE; st3WaitChk := FALSE; IF xSt3CheckUpDown THEN gSt3NextSide := 1; M257 := TRUE; ELSE gSt3NextSide := 2; M257 := FALSE; END_IF; ELSIF cySt3Suck.oErr THEN goNg := TRUE; END_IF; 70:	// get up gSt3Down := FALSE; IF cySt3Down.oOff THEN SET(TRUE, St3Done); goNext := TRUE; ELSIF cySt3Down.oErr THEN goNg := TRUE; END_IF; 80: // forward gSt3Forward := FALSE; IF cySt3Forward.oOff THEN goNext := TRUE; ELSIF cySt3Forward.oErr THEN goNg := TRUE; END_IF; 90:	// cycle done wSt3Index := OK_STEP; END_CASE; tmrSt3Vibrat1(IN:=st3Vibrat1,PT:=INT_TO_TIME(D1116*10)); tmrSt3Vibrat2(IN:=st3Vibrat2,PT:=INT_TO_TIME(D1117*10)); CASE wSt3Index OF 200:// forward gSt3Forward := TRUE; st3WaitChk := FALSE; IF cySt3Forward.oOn THEN goNext := TRUE; ELSIF cySt3Forward.oErr THEN SET(TRUE, goNg); END_IF; 210:	// down IF sys.ManMode THEN gSt3Down := TRUE; ELSIF sys.AutoMode THEN SET(gRotateArrived, gSt3Down); END_IF; IF cySt3Down.oOn THEN st3WaitChk := TRUE; goNext := TRUE; ELSIF cySt3Down.oErr THEN goNg := TRUE; END_IF; 220:	// place down gSt3Suck := FALSE; SET(TRUE, M0); IF cySt3Suck.oOff AND tmrSt3ChkUpDown.Q AND St3CanPick THEN RST(TRUE, M0); RST(TRUE, st3Sucking); goNext := TRUE; st3WaitChk := FALSE; IF xSt3CheckUpDown THEN gSt3NextSide := 1; M257 := TRUE; ELSE gSt3NextSide := 2; M257 := FALSE; END_IF; ELSIF cySt3Suck.oErr THEN goNg := TRUE; END_IF; 230:	// get up gSt3Down := FALSE; IF cySt3Down.oOff THEN goNext := TRUE; ELSIF cySt3Down.oErr THEN goNg := TRUE; END_IF; 240: // forward gSt3Forward := FALSE; IF cySt3Forward.oOff THEN goNext := TRUE; ELSIF cySt3Forward.oErr THEN goNg := TRUE; END_IF; 250: wSt3Index := 20; RST(TRUE, gSt3NeedCheck); END_CASE; IF goNg THEN wSt3LastIndex := wSt3Index; wSt3Index := NG_STEP; goNg := FALSE; END_IF; IF goNext AND canGoNext THEN wSt3Index := wSt3Index + 10; goNext := FALSE; END_IF; tmrSt3ChkUpDown(IN:=st3WaitChk, PT:=INT_TO_TIME(wSt3ToolChkT*100));
END_IF; St3InOrg := cySt3Down.oOff AND cySt3Forward.oOff AND cySt3Suck.oOff AND SM8000; canGoNext := NOT sys.HasError AND NOT cySt3Down.oErr AND NOT cySt3Forward.oErr AND //NOT F60 AND NOT cySt3Suck.oErr AND SM8000;
goNext	位 canGoNext	位 goNg	位 ; IF St5Cycle THEN IF wSt5Index = OK_STEP THEN St5Cycle := FALSE; wSt5Index := 0; ELSIF wSt5Index = NG_STEP THEN IF canGoNext THEN IF wSt5LastIndex = 30 THEN gSt5Down := TRUE; END_IF; wSt5Index := wSt5LastIndex; wSt5LastIndex := 0; END_IF; END_IF; IF sys.AutoMode THEN IF gSt5CanPick AND NOT gSt5Seperate THEN SET(TRUE, gSt5Seperate); END_IF; END_IF; CASE wSt5Index OF 10: IF sys.AutoMode THEN wDataArray[4] := 50 + STEP_BUSY; END_IF; IF NOT F56 THEN SET(gSt5CanPick OR sys.ManMode, gSt5Seperate); END_IF; IF cySt5Seperate.oOn AND cySt5Down.oOff AND cySt5Forward.oOff THEN goNext := TRUE; ELSIF cySt5Seperate.oErr THEN gSt5Seperate := FALSE; goNg := TRUE; END_IF; 20: SET(TRUE, gSt5Down); SET(TRUE, gSt5Suck); IF cySt5Down.oOn THEN RST(TRUE, gSt5SquareVacuum); SET(TRUE, goNext); ELSIF cySt5Down.oErr OR cySt5Suck.oErr THEN RST(TRUE, gSt5Down); RST(TRUE, gSt5Suck); SET(TRUE, goNg); END_IF; 30: SET(TRUE, gSt5Suck); RST(TRUE, gSt5SquareVacuum); IF cySt5Suck.oOn THEN goNext := TRUE; ELSIF cySt5Suck.oErr THEN RST(TRUE, gSt5Down); RST(TRUE, gSt5Suck); SET(TRUE, goNg); END_IF; 40: RST(TRUE, gSt5Down); IF cySt5Down.oOff THEN RST(TRUE, gSt5Seperate); goNext := TRUE; ELSIF cySt5Down.oErr THEN RST(TRUE, gSt5Down); SET(TRUE, goNg); END_IF; 50: gSt5Forward := TRUE; IF cySt5Forward.oOn THEN goNext := TRUE; ELSIF cySt5Forward.oErr THEN gSt5Forward := FALSE; SET(TRUE, goNg); END_IF; 60:	// place down the workpiece IF sys.ManMode THEN gSt5Down := TRUE; ELSIF sys.AutoMode THEN IF gRotateArrived THEN gSt5Down := TRUE; END_IF; END_IF; IF cySt5Down.oOn THEN goNext := TRUE; ELSIF cySt5Down.oErr THEN gSt5Down := FALSE; goNg := TRUE; END_IF; 70: gSt5Suck := FALSE; SET(TRUE, gSt5VacuumBreak); IF cySt5Suck.oOff THEN goNext := TRUE; END_IF; 80: gSt5Down := FALSE; IF cySt5Down.oOff THEN RST(TRUE, gSt5VacuumBreak); SET(TRUE, St5PutDone); goNext := TRUE; ELSIF cySt5Down.oErr THEN goNg := TRUE; END_IF; 90: gSt5Forward := FALSE; IF cySt5Forward.oOff AND cySt5Down.oOff THEN goNext := TRUE; ELSIF cySt5Forward.oErr THEN goNg := TRUE; END_IF; 100: wSt5Index := OK_STEP; END_CASE; IF goNg THEN goNg := FALSE; wSt5LastIndex := wSt5Index; wSt5Index := NG_STEP; END_IF; IF goNext AND canGoNext THEN wSt5Index := wSt5Index + 10; goNext := FALSE; END_IF;
END_IF; St5InOrg := cySt5Down.oOff AND cySt5Forward.oOff AND cySt5Suck.oOff AND SM8000; canGoNext := NOT sys.HasError AND NOT cySt5Down.oErr AND NOT cySt5Forward.oErr AND NOT cySt5Seperate.oErr AND NOT cySt5Suck.oErr AND SM8000;
]]></description><link>fx5u-sample.html</link><guid isPermaLink="false">個人/PLC/Sample/Fx5u - Sample.md</guid><pubDate>Sat, 06 Dec 2025 07:33:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Function Block Libaray(Fx5U)]]></title><description><![CDATA[iAct	Bit	VAR_INPUT	Action Cmd
oDevice	Bit	VAR_OUTPUT	Target Device
tmrOn	TON	VAR tmrOff	TON	VAR oOn	Bit	VAR_OUTPUT oOff	Bit	VAR_OUTPUT iOnDelay	Word [Signed]	VAR_INPUT	Sensor On延遲感測時間
iOffDelay	Word [Signed]	VAR_INPUT	Sensor Off延遲感測時間
tmrOnDelay	TON	VAR tmrOffDelay	TON	VAR ; oDevice := iAct; tmrOnDelay(IN := oDevice, PT := INT_TO_TIME(iOnDelay*10));
oOn := tmrOnDelay.Q; tmrOffDelay(IN := NOT oDevice, PT := INT_TO_TIME(iOffDelay*10));
oOff := tmrOffDelay.Q;
iAct	Bit	VAR_INPUT	Action Cmd
iRst	Bit	VAR_INPUT iOnDelay	Word [Signed]	VAR_INPUT	Target Device
iOffDelay	Word [Signed]	VAR_INPUT iOnTO	Word [Signed]	VAR_INPUT iOffTO	Word [Signed]	VAR_INPUT iLimit1	Bit	VAR_INPUT oDevice	Bit	VAR_OUTPUT	Sensor On延遲感測時間
tmrOn	TON	VAR	Sensor Off延遲感測時間
tmrOff	TON	VAR oOn	Bit	VAR_OUTPUT oOff	Bit	VAR_OUTPUT tmrOnDelay	TON	VAR tmrOffDelay	TON	VAR oErr	Bit	VAR_OUTPUT oErrId	Word [Signed]	VAR_OUTPUT // sensor 在動作(on)點 oDevice := iAct; tmrOn(IN := oDevice AND NOT iLimit1, PT:= INT_TO_TIME(iOnTO*10));
tmrOff(IN := NOT oDevice AND iLimit1, PT:= INT_TO_TIME(iOffTO*10)); RST(iRst AND oErr, oErr);
SET(tmrOn.Q OR tmrOff.Q, oErr); IF oErr THEN IF tmrOff.Q THEN oErrId := 20; ELSIF tmrOn.Q THEN oErrId := 10; END_IF;
ELSE oErrId := 0;
END_IF; tmrOnDelay(IN := oDevice AND iLimit1, PT := INT_TO_TIME(iOnDelay*10));
oOn := tmrOnDelay.Q; tmrOffDelay(IN := NOT oDevice, PT := INT_TO_TIME(iOffDelay*10));
oOff := tmrOffDelay.Q;
iAct	Bit	VAR_INPUT	Action Cmd
iRst	Bit	VAR_INPUT iOnDelay	Word [Signed]	VAR_INPUT	Target Device
iOffDelay	Word [Signed]	VAR_INPUT iOnTO	Word [Signed]	VAR_INPUT iOffTO	Word [Signed]	VAR_INPUT iLimit1	Bit	VAR_INPUT oDevice	Bit	VAR_OUTPUT	Sensor On延遲感測時間
tmrOn	TON	VAR	Sensor Off延遲感測時間
tmrOff	TON	VAR oOn	Bit	VAR_OUTPUT oOff	Bit	VAR_OUTPUT tmrOnDelay	TON	VAR tmrOffDelay	TON	VAR oErr	Bit	VAR_OUTPUT oErrId	Word [Signed]	VAR_OUTPUT oDevice := iAct; tmrOff(IN := (NOT oDevice AND NOT iLimit1), PT := INT_TO_TIME(iOffTO*10)); RST(iRst AND oErr, oErr);
SET(tmrOff.Q, oErr); IF oErr THEN IF tmrOff.Q THEN oErrId := 20; END_IF;
ELSE oErrId := 0;
END_IF; tmrOnDelay(IN := oDevice, PT := INT_TO_TIME(iOnDelay*10));
oOn := tmrOnDelay.Q; tmrOffDelay(IN := NOT oDevice AND iLimit1, PT := INT_TO_TIME(iOffDelay*10));
oOff := tmrOffDelay.Q;
iAct	Bit	VAR_INPUT Action Cmd
iRst	Bit	VAR_INPUT iOnDelay	Word [Signed]	VAR_INPUT Target Device
iOffDelay	Word [Signed]	VAR_INPUT iOnTO	Word [Signed]	VAR_INPUT iOffTO	Word [Signed]	VAR_INPUT iLimit1	Bit	VAR_INPUT iLimit2	Bit	VAR_INPUT oDevice	Bit	VAR_OUTPUT Sensor On延遲感測時間
oOn	Bit	VAR_OUTPUT oOff	Bit	VAR_OUTPUT oErr	Bit	VAR_OUTPUT oErrId	Word [Unsigned]/Bit String [16-bit]	VAR_OUTPUT tmrOn	TON	VAR Sensor Off延遲感測時間
tmrOff	TON	VAR tmrErr	TON	VAR tmrOnDelay	TON	VAR tmrOffDelay	TON	VAR tmpValue	Word [Unsigned]/Bit String [16-bit]	VAR oDevice := iAct; tmrOn(IN := oDevice AND NOT iLimit2, PT:= INT_TO_TIME(iOnTO * 10));
tmrOff(IN := NOT oDevice AND NOT iLimit1, PT := INT_TO_TIME(iOffTO * 10));
tmrErr(IN := iLimit1 AND iLimit2, PT := T#10s); RST(iRst AND oErr, oErr);
SET(tmrOn.Q OR tmrOff.Q OR tmrErr.Q, oErr); IF (oErr) THEN IF tmrOn.Q THEN oErrId := 10; ELSIF tmrOff.Q THEN oErrId := 20; END_IF; IF tmrErr.Q THEN oErrId := 30; END_IF;
ELSE oErrId := 0;
END_IF; tmrOnDelay(IN := oDevice AND iLimit2, PT := INT_TO_TIME(iOnDelay*10));
oOn := tmrOnDelay.Q; tmrOffDelay(IN := NOT oDevice AND iLimit1, PT := INT_TO_TIME(iOffDelay*10));
oOff := tmrOffDelay.Q; iOrigPos	位	VAR_INPUT iActPos	位	VAR_INPUT iStop	位	VAR_INPUT iRun	位	VAR_INPUT iReset	位	VAR_INPUT iRotateTO	字[有符号]	VAR_INPUT iInPosWaitTime	字[有符号]	VAR_INPUT oDevice	位	VAR_OUTPUT oBusy	位	VAR_OUTPUT oErr	位	VAR_OUTPUT oArrived	位	VAR_OUTPUT rotating	位	VAR tmrWaitInPos	TON	VAR inPos	位	VAR waitInPos	位	VAR arrived	位	VAR rotate	位	VAR reset	位	VAR tmrTimeOut	TON	VAR tmp	位	VAR ; i've converted this from FBD(use this for learn purpose in beginning, and i've lost the original st version Orz...), so it may have compile issue. PLS(iRun, rotate); tmp := (not arrived) and (not iStop) and (rotate or rotating);
rotating := tmp;
oDevice := (not oErr) and tmp; reset := iReset;
tmrTimeOut(IN := oDevice and not reset, PT := INT_TO_TIME(IN := iRotateTO * 100)); oErr := not reset and (tmrTimeOut.Q or oErr); inPos := not tmrWaitInPos.Q and not iStop or ((rotating and PLS(iOrigPos)) or inPos); waitInPos := not tmrWaitInPos.Q and ( ( not iStop or ((rotating and PLS(iOrigPos)) or inPos) ) or waitInPos); tmrWaitInPos(IN:= ((inPos and waitInPos) or arrived) and not iStop and not tmrWaitInPos.Q, PT := INT_TO_TIME(IN:= iInPosWaittime)); arrived := ((inPos and waitInPos) or arrived) and not iStop and not tmrWaitInPos.Q; oBusy := rotating and not arrived; SET(tmrWaitInPos.Q, oArrived);
RST(PLS(rotate), oArrived); iAct	位	VAR_INPUT iFull	位	VAR_INPUT iArrived	位	VAR_INPUT iFullOnT	字[有符号]	VAR_INPUT iFullOffT	字[有符号]	VAR_INPUT iArrivedOnT	字[有符号]	VAR_INPUT iSupplyTO	字[有符号]	VAR_INPUT iArriveTO	字[有符号]	VAR_INPUT oFeeder	位	VAR_OUTPUT oLinearFeeder	位	VAR_OUTPUT oCanPick	位	VAR_OUTPUT oNeedSupply	位	VAR_OUTPUT oArriveTO	位	VAR_OUTPUT tmrArrivedOn	TON	VAR tmrFullOn	TON	VAR tmrNeedSupply	TON	VAR tmrFullOff	TON	VAR tmrArriveTO	TON	VAR oLinearFeeder := iAct; tmrArriveTO( IN := iAct AND NOT iArrived, PT := INT_TO_TIME(iArriveTO*100)); tmrArrivedOn( IN := iAct AND iArrived, PT := INT_TO_TIME(iArrivedOnT*100)); oCanPick := iAct AND tmrArrivedOn.Q; tmrFullOn( IN := iAct AND iFull, PT := INT_TO_TIME(iFullOnT*100)); tmrFullOff( IN := iAct AND NOT iFull, PT := INT_TO_TIME(iFullOffT*100)); IF iAct THEN IF LDP(TRUE, tmrFullOff.Q) THEN SET(TRUE, oFeeder); END_IF; IF LDP(TRUE, tmrFullOn.Q) THEN RST(TRUE, oFeeder); END_IF;
ELSE RST(TRUE, oFeeder);
END_IF; tmrNeedSupply( IN := iAct AND oFeeder, PT := INT_TO_TIME(iSupplyTO*100)); oNeedSupply := iAct AND tmrNeedSupply.Q AND (NOT tmrFullOn.Q); oArriveTO := tmrArriveTO.Q; iAct	位	VAR_INPUT iAxisNo	字[无符号]/位串[16位]	VAR_INPUT iHomeSpeed	字[无符号]/位串[16位]	VAR_INPUT iApproachSpeed	字[无符号]/位串[16位]	VAR_INPUT iStop	位	VAR_INPUT oBusy	位	VAR_OUTPUT oDone	位	VAR_OUTPUT oErr	位	VAR_OUTPUT done	位	VAR <img src="assets/pasted-image-20251206152618.png" target="_self">iAct	位	VAR_INPUT iAxisNo	字[无符号]/位串[16位]	VAR_INPUT iSpeed	字[无符号]/位串[16位]	VAR_INPUT iStop	位	VAR_INPUT oBusy	位	VAR_OUTPUT oDone	位	VAR_OUTPUT oErr	位	VAR_OUTPUT done	位	VAR iDest	双字[有符号]	VAR_INPUT <br><img src="assets/pasted-image-20251206152757.png" target="_self">iStatus	dsSysStatus	VAR_INPUT hasErr	位	VAR oLights	dsTowerLight	VAR_OUTPUT iStopBuzzer	位	VAR_INPUT keepStopBuzzer	位	VAR <br><img src="assets/pasted-image-20251206153519.png" target="_self">iStatus	dsSysStatus	VAR_IN_OUT iTrig	dsSysTrigger	VAR_IN_OUT <br><img src="assets/pasted-image-20251206153653.png" target="_self"><br>
<img src="assets/pasted-image-20251206153721.png" target="_self"><br>
<img src="assets/pasted-image-20251206153740.png" target="_self">]]></description><link>function-block-libaray(fx5u).html</link><guid isPermaLink="false">個人/PLC/Function Block Libaray(Fx5U).md</guid><pubDate>Sat, 06 Dec 2025 07:37:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>